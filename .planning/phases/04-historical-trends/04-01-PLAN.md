---
phase: 04-historical-trends
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/trend_service.py
  - backend/app/schemas/trend.py
  - backend/app/api/v1/trends.py
  - backend/app/api/v1/router.py
autonomous: true

must_haves:
  truths:
    - "User can view 7-day score trend for each goal"
    - "Week-over-week comparison shows improvement or decline percentage"
    - "Trend data is structured for mobile visualization consumption"
  artifacts:
    - path: "backend/app/services/trend_service.py"
      provides: "Trend aggregation from DailyScore/ScoreMetric"
      exports: ["TrendService"]
    - path: "backend/app/schemas/trend.py"
      provides: "Response schemas for trend data"
      exports: ["GoalTrendRead", "TrendDataPoint", "WeekOverWeekComparison"]
    - path: "backend/app/api/v1/trends.py"
      provides: "Trend API endpoints"
      exports: ["router"]
  key_links:
    - from: "backend/app/api/v1/trends.py"
      to: "backend/app/services/trend_service.py"
      via: "TrendService instantiation"
      pattern: "TrendService\\(db\\)"
    - from: "backend/app/services/trend_service.py"
      to: "backend/app/models/daily_score.py"
      via: "SQLAlchemy query"
      pattern: "select\\(.*ScoreMetric.*\\)"
    - from: "backend/app/api/v1/router.py"
      to: "backend/app/api/v1/trends.py"
      via: "router inclusion"
      pattern: "include_router\\(trends\\.router\\)"
---

<objective>
Build historical trend tracking that aggregates DailyScore data into per-goal trend views.

Purpose: Enable users to visualize their progress over time and see week-over-week improvement or decline for each goal. This data powers mobile chart visualizations.

Output: TrendService with aggregation logic, Pydantic schemas for mobile consumption, and a trends API endpoint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@D:\projects\AI\amibetter\.planning\PROJECT.md
@D:\projects\AI\amibetter\.planning\ROADMAP.md
@D:\projects\AI\amibetter\.planning\STATE.md

@D:\projects\AI\amibetter\backend\app\models\daily_score.py
@D:\projects\AI\amibetter\backend\app\models\goal.py
@D:\projects\AI\amibetter\backend\app\schemas\score.py
@D:\projects\AI\amibetter\backend\app\services\goal_service.py
@D:\projects\AI\amibetter\backend\app\api\v1\goals.py
@D:\projects\AI\amibetter\backend\app\api\v1\router.py
@D:\projects\AI\amibetter\backend\app\deps.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TrendService for score aggregation</name>
  <files>backend/app/services/trend_service.py</files>
  <action>
Create TrendService class following existing service patterns (GoalService as reference).

Constructor: Takes AsyncSession via dependency injection.

Methods:

1. `get_goal_trend(user_id: UUID, goal_category: str, days: int = 7) -> list[TrendDataPoint]`
   - Query ScoreMetric joined with DailyScore for the specified goal category
   - Filter by user_id and date range (today minus days to today)
   - Return list of (date, score) pairs ordered by date ascending
   - Handle missing days by NOT including them (sparse data, let frontend fill gaps)

2. `get_all_goals_trends(user_id: UUID, days: int = 7) -> dict[str, list[TrendDataPoint]]`
   - Get trends for all of user's active goals in one query
   - Return dict keyed by goal category

3. `calculate_week_over_week(user_id: UUID, goal_category: str) -> WeekOverWeekComparison`
   - Calculate average score for this week (last 7 days) vs previous week (8-14 days ago)
   - Return percentage change: ((this_week_avg - last_week_avg) / last_week_avg) * 100
   - Handle edge cases: no data for either week returns None for percentage
   - Include raw averages in response for display

Query pattern:
```python
from sqlalchemy import select, and_
from sqlalchemy.orm import joinedload

result = await self.db.execute(
    select(ScoreMetric)
    .join(DailyScore)
    .where(
        and_(
            DailyScore.user_id == user_id,
            DailyScore.score_date >= start_date,
            DailyScore.score_date <= end_date,
            ScoreMetric.category == goal_category,
        )
    )
    .order_by(DailyScore.score_date)
)
```
  </action>
  <verify>
File exists at backend/app/services/trend_service.py with TrendService class and three methods. Import succeeds: `python -c "from app.services.trend_service import TrendService"`
  </verify>
  <done>
TrendService class exists with get_goal_trend, get_all_goals_trends, and calculate_week_over_week methods. Service follows async pattern and queries ScoreMetric/DailyScore correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create trend response schemas</name>
  <files>backend/app/schemas/trend.py</files>
  <action>
Create Pydantic schemas for trend API responses, optimized for mobile consumption.

Schemas:

1. `TrendDataPoint` - Single day's score for a goal
   ```python
   class TrendDataPoint(BaseModel):
       date: date
       score: float  # 0-10 scale (from ScoreMetric)

       model_config = {"from_attributes": True}
   ```

2. `WeekOverWeekComparison` - Week comparison result
   ```python
   class WeekOverWeekComparison(BaseModel):
       this_week_avg: float | None  # None if no data
       last_week_avg: float | None  # None if no data
       percentage_change: float | None  # None if can't calculate
       trend: str  # "improving" | "declining" | "stable" | "insufficient_data"
   ```
   - "improving": percentage_change > 5%
   - "declining": percentage_change < -5%
   - "stable": -5% <= percentage_change <= 5%
   - "insufficient_data": either week has no data

3. `GoalTrendRead` - Complete trend data for one goal
   ```python
   class GoalTrendRead(BaseModel):
       goal_category: str
       goal_description: str | None  # From UserGoal if available
       data_points: list[TrendDataPoint]
       week_over_week: WeekOverWeekComparison
   ```

4. `TrendsResponse` - All goals trends response
   ```python
   class TrendsResponse(BaseModel):
       user_id: UUID
       generated_at: datetime
       trends: list[GoalTrendRead]
   ```

Mobile-friendly design:
- Flat structures (no deeply nested objects)
- Pre-computed trend direction (mobile doesn't need to calculate)
- Explicit nullability for missing data
  </action>
  <verify>
File exists at backend/app/schemas/trend.py. Import succeeds: `python -c "from app.schemas.trend import TrendDataPoint, WeekOverWeekComparison, GoalTrendRead, TrendsResponse"`
  </verify>
  <done>
Pydantic schemas TrendDataPoint, WeekOverWeekComparison, GoalTrendRead, and TrendsResponse exist with proper typing and mobile-friendly structure.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create trends API endpoint and wire router</name>
  <files>backend/app/api/v1/trends.py, backend/app/api/v1/router.py</files>
  <action>
Create trends.py router following existing patterns (goals.py as reference).

Endpoints:

1. `GET /api/v1/trends` - Get trends for all user goals
   ```python
   @router.get("/", response_model=TrendsResponse)
   async def get_all_trends(
       db: DbSession,
       current_user: CurrentUser,
       days: int = Query(default=7, ge=1, le=30),
   ):
   ```
   - Uses TrendService.get_all_goals_trends()
   - Also fetches goals via GoalService to get descriptions
   - Calculates week_over_week for each goal
   - Returns TrendsResponse

2. `GET /api/v1/trends/{goal_category}` - Get trend for specific goal
   ```python
   @router.get("/{goal_category}", response_model=GoalTrendRead)
   async def get_goal_trend(
       goal_category: str,
       db: DbSession,
       current_user: CurrentUser,
       days: int = Query(default=7, ge=1, le=30),
   ):
   ```
   - Validates goal_category exists for user (404 if not)
   - Returns single GoalTrendRead

Router setup:
```python
router = APIRouter(prefix="/trends", tags=["trends"])
```

Wire into main router (router.py):
- Import trends module
- Add: `api_router.include_router(trends.router)`
  </action>
  <verify>
1. File exists at backend/app/api/v1/trends.py with router
2. router.py includes trends router
3. Server starts without import errors: `cd backend && python -c "from app.api.v1.router import api_router; print('Router OK')"`
4. Endpoint registered: `cd backend && python -c "from app.main import app; routes = [r.path for r in app.routes if hasattr(r, 'path')]; print([r for r in routes if 'trend' in r.lower()])"`
  </verify>
  <done>
Trends API endpoints exist at GET /api/v1/trends and GET /api/v1/trends/{goal_category}. Router is wired into main API router. Server starts and endpoints are registered.
  </done>
</task>

</tasks>

<verification>
1. All files exist:
   - backend/app/services/trend_service.py
   - backend/app/schemas/trend.py
   - backend/app/api/v1/trends.py

2. Server starts: `cd backend && uvicorn app.main:app --host 0.0.0.0 --port 8000` (no import errors)

3. API docs show endpoints: Visit http://localhost:8000/docs and verify /api/v1/trends endpoints appear

4. Schemas validate correctly:
   ```python
   from app.schemas.trend import TrendsResponse, GoalTrendRead
   from datetime import date, datetime
   from uuid import uuid4

   # Should not raise
   GoalTrendRead(
       goal_category="fitness",
       goal_description="Exercise daily",
       data_points=[{"date": date.today(), "score": 7.5}],
       week_over_week={"this_week_avg": 7.5, "last_week_avg": 6.0, "percentage_change": 25.0, "trend": "improving"}
   )
   ```
</verification>

<success_criteria>
1. TrendService aggregates ScoreMetric data by goal category and date range
2. Week-over-week comparison calculates percentage change with proper edge case handling
3. GET /api/v1/trends returns trends for all user goals with pre-computed trend direction
4. GET /api/v1/trends/{goal_category} returns trend for specific goal
5. Response schemas are mobile-friendly (flat structure, explicit nulls, pre-computed values)
6. API follows existing codebase patterns (service injection, deps.py types, Pydantic schemas)
</success_criteria>

<output>
After completion, create `.planning/phases/04-historical-trends/04-01-SUMMARY.md`
</output>
